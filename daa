import java.util.Comparator; 
import java.util.PriorityQueue; 
import java.util.Scanner; 

class Huffman { 

	// recursive function to print the 
	// huffman-code through the tree traversal. 
	// Here s is the huffman - code generated. 
	public static void printCode(HuffmanNode root, String s) 
	{ 

		// base case; if the left and right are null 
		// then its a leaf node and we print 
		// the code s generated by traversing the tree. 
		if (root.left == null && root.right == null
			&& Character.isLetter(root.c)) { 

			// c is the character in the node 
			System.out.println(root.c + ":" + s); 

			return; 
		} 

		// if we go to left then add "0" to the code. 
		// if we go to the right add"1" to the code. 

		// recursive calls for left and 
		// right sub-tree of the generated tree. 
		printCode(root.left, s + "0"); 
		printCode(root.right, s + "1"); 
	} 

	// main function 
	public static void main(String[] args) 
	{ 

		Scanner s = new Scanner(System.in); 

		// number of characters. 
		int n = 6; 
		char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' }; 
		int[] charfreq = { 5, 9, 12, 13, 16, 45 }; 

		// creating a priority queue q. 
		// makes a min-priority queue(min-heap). 
		PriorityQueue<HuffmanNode> q 
			= new PriorityQueue<HuffmanNode>( 
				n, new MyComparator()); 

		for (int i = 0; i < n; i++) { 

			// creating a Huffman node object 
			// and add it to the priority queue. 
			HuffmanNode hn = new HuffmanNode(); 

			hn.c = charArray[i]; 
			hn.data = charfreq[i]; 

			hn.left = null; 
			hn.right = null; 

			// add functions adds 
			// the huffman node to the queue. 
			q.add(hn); 
		} 

		// create a root node 
		HuffmanNode root = null; 

		// Here we will extract the two minimum value 
		// from the heap each time until 
		// its size reduces to 1, extract until 
		// all the nodes are extracted. 
		while (q.size() > 1) { 

			// first min extract. 
			HuffmanNode x = q.peek(); 
			q.poll(); 

			// second min extract. 
			HuffmanNode y = q.peek(); 
			q.poll(); 

			// new node f which is equal 
			HuffmanNode f = new HuffmanNode(); 

			// to the sum of the frequency of the two nodes 
			// assigning values to the f node. 
			f.data = x.data + y.data; 
			f.c = '-'; 

			// first extracted node as left child. 
			f.left = x; 

			// second extracted node as the right child. 
			f.right = y; 

			// marking the f node as the root node. 
			root = f; 

			// add this node to the priority-queue. 
			q.add(f); 
		} 

		// print the codes by traversing the tree 
		printCode(root, ""); 
	} 
} 

// node class is the basic structure 
// of each node present in the Huffman - tree. 
class HuffmanNode { 

	int data; 
	char c; 

	HuffmanNode left; 
	HuffmanNode right; 
} 

// comparator class helps to compare the node 
// on the basis of one of its attribute. 
// Here we will be compared 
// on the basis of data values of the nodes. 
class MyComparator implements Comparator<HuffmanNode> { 
	public int compare(HuffmanNode x, HuffmanNode y) 
	{ 

		return x.data - y.data; 
	} 
} 

// This code is contributed by Kunwar Desh Deepak Singh







// Java program to solve fractional Knapsack Problem

import java.lang.*;
import java.util.Arrays;
import java.util.Comparator;

// Greedy approach
public class FractionalKnapSack {
	
	// Function to get maximum value
	private static double getMaxValue(ItemValue[] arr,
									int capacity)
	{
		// Sorting items by profit/weight ratio;
		Arrays.sort(arr, new Comparator<ItemValue>() {
			@Override
			public int compare(ItemValue item1,
							ItemValue item2)
			{
				double cpr1
					= new Double((double)item1.profit
								/ (double)item1.weight);
				double cpr2
					= new Double((double)item2.profit
								/ (double)item2.weight);

				if (cpr1 < cpr2)
					return 1;
				else
					return -1;
			}
		});

		double totalValue = 0d;

		for (ItemValue i : arr) {

			int curWt = (int)i.weight;
			int curVal = (int)i.profit;

			if (capacity - curWt >= 0) {

				// This weight can be picked whole
				capacity = capacity - curWt;
				totalValue += curVal;
			}
			else {

				// Item cant be picked whole
				double fraction
					= ((double)capacity / (double)curWt);
				totalValue += (curVal * fraction);
				capacity
					= (int)(capacity - (curWt * fraction));
				break;
			}
		}

		return totalValue;
	}

	// Item value class
	static class ItemValue {

		int profit, weight;

		// Item value function
		public ItemValue(int val, int wt)
		{
			this.weight = wt;
			this.profit = val;
		}
	}

	// Driver code
	public static void main(String[] args)
	{

		ItemValue[] arr = { new ItemValue(60, 10),
							new ItemValue(100, 20),
							new ItemValue(120, 30) };

		int capacity = 50;

		double maxValue = getMaxValue(arr, capacity);

		// Function call
		System.out.println(maxValue);
	}
}





import java.util.*; 

class KnapsackNode { 
// The items that have been included in the knapsack so far 
List<Integer> items; 
// The total value of the items in the knapsack so far 
int value; 
// The total weight of the items in the knapsack so far 
int weight; 

public KnapsackNode(List<Integer> items, int value, int weight) { 
	this.items = items; 
	this.value = value; 
	this.weight = weight; 
} 
} 

class Item { 
// The value of the item 
int value; 
// The weight of the item 
int weight; 
// The value-to-weight ratio of the item 
double ratio; 

public Item(int value, int weight) { 
	this.value = value; 
	this.weight = weight; 
	this.ratio = (double) value / weight; 
} 
} 

public class Knapsack { 
// The maximum weight capacity of the knapsack 
int maxWeight; 
// The list of items 
Item[] items; 

public Knapsack(int maxWeight, Item[] items) { 
	this.maxWeight = maxWeight; 
	this.items = items; 
} 

// Solves the 0/1 knapsack problem using branch and bound 
public int solve() { 
	// Sort the items in decreasing order of value per unit weight 
	Arrays.sort(items, (a, b) -> -Double.compare(a.ratio, b.ratio)); 

	// The best value found so far 
	int bestValue = 0; 

	// The queue of nodes to be explored 
	Queue<KnapsackNode> queue = new LinkedList<>(); 
	queue.add(new KnapsackNode(new ArrayList<>(), 0, 0)); 

	while (!queue.isEmpty()) { 
	KnapsackNode node = queue.poll(); 
	int i = node.items.size(); 
	if (i == items.length) { 
		// This is a leaf node, so update the best value if necessary 
		bestValue = Math.max(bestValue, node.value); 
	} else { 
		// Add the child nodes for the remaining items 
		Item item = items[i]; 
		KnapsackNode withItem = new KnapsackNode( 
		new ArrayList<>(node.items), node.value + item.value, node.weight + item.weight); 
		if (isPromising(withItem, maxWeight, bestValue)) { 
		queue.add(withItem); 
		} 
		KnapsackNode withoutItem = new KnapsackNode( 
		new ArrayList<>(node.items), node.value, node.weight); 
		if (isPromising(withoutItem, maxWeight, bestValue)) { 
		queue.add(withoutItem); 
		} 
	} 
	} 

	return bestValue; 
} 

// Returns true if the given node is promising (i.e., it may lead to a better solution than the current best) 
private boolean isPromising(KnapsackNode node, int maxWeight, int best





                            // Java program to solve N Queen Problem using backtracking

import java.util.*;

class GFG {
	static int N = 4;

	// ld is an array where its indices indicate row-col+N-1
	// (N-1) is for shifting the difference to store
	// negative indices
	static int[] ld = new int[30];

	// rd is an array where its indices indicate row+col
	// and used to check whether a queen can be placed on
	// right diagonal or not
	static int[] rd = new int[30];

	// Column array where its indices indicates column and
	// used to check whether a queen can be placed in that
	// row or not
	static int[] cl = new int[30];

	// A utility function to print solution
	static void printSolution(int board[][])
	{
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++)
				System.out.printf(" %d ", board[i][j]);
			System.out.printf("\n");
		}
	}

	// A recursive utility function to solve N
	// Queen problem
	static boolean solveNQUtil(int board[][], int col)
	{
		// Base case: If all queens are placed
		// then return true
		if (col >= N)
			return true;

		// Consider this column and try placing
		// this queen in all rows one by one
		for (int i = 0; i < N; i++) {
			// Check if the queen can be placed on
			// board[i][col]

			// To check if a queen can be placed on
			// board[row][col].We just need to check
			// ld[row-col+n-1] and rd[row+coln] where
			// ld and rd are for left and right
			// diagonal respectively
			if ((ld[i - col + N - 1] != 1
				&& rd[i + col] != 1)
				&& cl[i] != 1) {
				// Place this queen in board[i][col]
				board[i][col] = 1;
				ld[i - col + N - 1] = rd[i + col] = cl[i]
					= 1;

				// Recur to place rest of the queens
				if (solveNQUtil(board, col + 1))
					return true;

				// If placing queen in board[i][col]
				// doesn't lead to a solution, then
				// remove queen from board[i][col]
				board[i][col] = 0; // BACKTRACK
				ld[i - col + N - 1] = rd[i + col] = cl[i]
					= 0;
			}
		}

		// If the queen cannot be placed in any row in
		// this column col then return false
		return false;
	}

	// This function solves the N Queen problem using
	// Backtracking. It mainly uses solveNQUtil() to
	// solve the problem. It returns false if queens
	// cannot be placed, otherwise, return true and
	// prints placement of queens in the form of 1s.
	// Please note that there may be more than one
	// solutions, this function prints one of the
	// feasible solutions.
	static boolean solveNQ()
	{
		int board[][] = { { 0, 0, 0, 0 },
						{ 0, 0, 0, 0 },
						{ 0, 0, 0, 0 },
						{ 0, 0, 0, 0 } };

		if (solveNQUtil(board, 0) == false) {
			System.out.printf("Solution does not exist");
			return false;
		}

		printSolution(board);
		return true;
	}

	// Driver Code
	public static void main(String[] args) 
	{ 
		solveNQ(); 
	}
}

// This code is contributed by Princi Singh




// Java program to illustrate
// Randomised Quick Sort 
import java.util.*; 

class RandomizedQsort 
{	 
	// This Function helps in calculating
	// random numbers between low(inclusive)
	// and high(inclusive) 
	static void random(int arr[],int low,int high) 
	{ 
	
		Random rand= new Random(); 
		int pivot = rand.nextInt(high-low)+low; 
		
		int temp1=arr[pivot]; 
		arr[pivot]=arr[high]; 
		arr[high]=temp1; 
	} 
	
	/* This function takes last element as pivot, 
	places the pivot element at its correct 
	position in sorted array, and places all 
	smaller (smaller than pivot) to left of 
	pivot and all greater elements to right 
	of pivot */
	static int partition(int arr[], int low, int high) 
	{ 
		// pivot is chosen randomly 
		random(arr,low,high);
		int pivot = arr[high]; 
	

		int i = (low-1); // index of smaller element 
		for (int j = low; j < high; j++) 
		{ 
			// If current element is smaller than or 
			// equal to pivot 
			if (arr[j] < pivot) 
			{ 
				i++; 

				// swap arr[i] and arr[j] 
				int temp = arr[i]; 
				arr[i] = arr[j]; 
				arr[j] = temp; 
			} 
		} 

		// swap arr[i+1] and arr[high] (or pivot) 
		int temp = arr[i+1]; 
		arr[i+1] = arr[high]; 
		arr[high] = temp; 

		return i+1; 
	} 


	/* The main function that implements QuickSort() 
	arr[] --> Array to be sorted, 
	low --> Starting index, 
	high --> Ending index */
	static void sort(int arr[], int low, int high) 
	{ 
		if (low < high) 
		{ 
			/* pi is partitioning index, arr[pi] is 
			now at right place */
			int pi = partition(arr, low, high); 

			// Recursively sort elements before 
			// partition and after partition 
			sort(arr, low, pi-1); 
			sort(arr, pi+1, high); 
		} 
	} 

	/* A utility function to print array of size n */
	static void printArray(int arr[]) 
	{ 
		int n = arr.length; 
		for (int i = 0; i < n; ++i) 
			System.out.print(arr[i]+" "); 
		System.out.println(); 
	} 

	// Driver Code 
	public static void main(String args[]) 
	{ 
		int arr[] = {10, 7, 8, 9, 1, 5}; 
		int n = arr.length; 

		sort(arr, 0, n-1); 

		System.out.println("Sorted array"); 
		printArray(arr); 
	} 
} 

// This code is contributed by Ritika Gupta.

                            




import java.util.Arrays;
import java.util.Comparator;
import java.util.PriorityQueue;

class Item {
    float weight;
    int value;

    Item(float weight, int value) {
        this.weight = weight;
        this.value = value;
    }
}

class Node {
    int level, profit, bound;
    float weight;

    Node(int level, int profit, float weight) {
        this.level = level;
        this.profit = profit;
        this.weight = weight;
    }
}

public class KnapsackBranchAndBound {
    static Comparator<Item> itemComparator = (a, b) -> {
        double ratio1 = (double) a.value / a.weight;
        double ratio2 = (double) b.value / b.weight;
        // Sorting in decreasing order of value per unit weight
        return Double.compare(ratio2, ratio1);
    };

    static int bound(Node u, int n, int W, Item[] arr) {
        if (u.weight >= W)
            return 0;

        int profitBound = u.profit;
        int j = u.level + 1;
        float totalWeight = u.weight;

        while (j < n && totalWeight + arr[j].weight <= W) {
            totalWeight += arr[j].weight;
            profitBound += arr[j].value;
            j++;
        }

        if (j < n)
            profitBound += (int) ((W - totalWeight) * arr[j].value / arr[j].weight);

        return profitBound;
    }

    static int knapsack(int W, Item[] arr, int n) {
        Arrays.sort(arr, itemComparator);
        PriorityQueue<Node> priorityQueue =
                new PriorityQueue<>((a, b) -> Integer.compare(b.bound, a.bound));
        Node u, v;

        u = new Node(-1, 0, 0);
        priorityQueue.offer(u);

        int maxProfit = 0;

        while (!priorityQueue.isEmpty()) {
            u = priorityQueue.poll();

            if (u.level == -1)
                v = new Node(0, 0, 0);
            else if (u.level == n - 1)
                continue;
            else
                v = new Node(u.level + 1, u.profit, u.weight);

            v.weight += arr[v.level].weight;
            v.profit += arr[v.level].value;

            if (v.weight <= W && v.profit > maxProfit)
                maxProfit = v.profit;

            v.bound = bound(v, n, W, arr);

            if (v.bound > maxProfit)
                priorityQueue.offer(v);

            v = new Node(u.level + 1, u.profit, u.weight);
            v.bound = bound(v, n, W, arr);

            if (v.bound > maxProfit)
                priorityQueue.offer(v);
        }

        return maxProfit;
    }

    public static void main(String[] args) {
        int W = 10;
        Item[] arr = {
                new Item(2, 40),
                new Item(3.14f, 50),
                new Item(1.98f, 100),
                new Item(5, 95),
                new Item(3, 30)
        };
        int n = arr.length;

        int maxProfit = knapsack(W, arr, n);
        System.out.println("Maximum possible profit = " + maxProfit);
    }
}

